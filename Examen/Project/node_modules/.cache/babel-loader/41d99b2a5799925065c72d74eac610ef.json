{"ast":null,"code":"var _jsxFileName = \"D:\\\\Laboratoare\\\\ANUL 3\\\\Semestrul 1\\\\ProgramarepentruDispozitiveMobile\\\\Examen\\\\Project\\\\src\\\\todo\\\\ItemProvider.tsx\";\nimport React, { useCallback, useEffect, useReducer } from 'react';\nimport { getLogger } from '../core';\nimport { getProductsPage, newWebSocket, uploadItem } from './itemApi';\nconst log = getLogger('ItemProvider');\nconst initialState = {\n  fetching: false,\n  saving: false,\n  canReDownload: false,\n  page: 0,\n  total: 0,\n  uploading: false,\n  uploadNr: 0\n};\nconst FETCH_ITEMS_STARTED = 'FETCH_ITEMS_STARTED';\nconst FETCH_ITEMS_SUCCEEDED = 'FETCH_ITEMS_SUCCEEDED';\nconst FETCH_ITEMS_FAILED = 'FETCH_ITEMS_FAILED';\nconst SAVE_ITEM_STARTED = 'SAVE_ITEM_STARTED';\nconst UPLOAD_ITEM_STARTED = 'UPLOAD_ITEM_STARTED';\nconst UPLOAD_ITEM_SUCCEEDED = 'UPLOAD_ITEM_SUCCEEDED';\nconst UPLOADED_ITEM = 'UPLOADED_ITEM';\nconst UPLOAD_ITEM_FAILED = 'UPLOAD_ITEM_FAILED';\nconst SAVE_ITEM_SUCCEEDED = 'SAVE_ITEM_SUCCEEDED';\nconst SAVE_ITEM_FAILED = 'SAVE_ITEM_FAILED';\nconst PAGE_CHANGED = 'PAGE_CHANGED';\nconst CAN_REDOWNLOAD = 'CAN_REDOWNLOAD';\n\nconst reducer = (state, {\n  type,\n  payload\n}) => {\n  switch (type) {\n    case PAGE_CHANGED:\n      return { ...state,\n        page: payload.page,\n        total: payload.total,\n        canReDownload: false\n      };\n\n    case CAN_REDOWNLOAD:\n      return { ...state,\n        canReDownload: true\n      };\n\n    case FETCH_ITEMS_STARTED:\n      return { ...state,\n        fetching: true,\n        fetchingError: null\n      };\n\n    case FETCH_ITEMS_SUCCEEDED:\n      localStorage.setItem(\"products\", JSON.stringify(payload.items));\n      return { ...state,\n        products: payload.items,\n        fetching: false\n      };\n\n    case UPLOAD_ITEM_STARTED:\n      return { ...state,\n        uploading: true,\n        uploadNr: 0\n      };\n\n    case UPLOAD_ITEM_SUCCEEDED:\n      localStorage.setItem(\"items\", JSON.stringify([]));\n      return { ...state,\n        uploading: false,\n        items: []\n      };\n\n    case UPLOAD_ITEM_FAILED:\n      return { ...state,\n        uploading: false\n      };\n\n    case UPLOADED_ITEM:\n      return { ...state,\n        uploadNr: state.uploadNr + 1\n      };\n\n    case FETCH_ITEMS_FAILED:\n      return { ...state,\n        fetchingError: payload.error,\n        fetching: false,\n        canReDownload: true\n      };\n\n    case SAVE_ITEM_STARTED:\n      return { ...state,\n        savingError: null,\n        saving: true\n      };\n\n    case SAVE_ITEM_SUCCEEDED:\n      const items = [...(state.items || [])]; //const item = payload.item;\n\n      if (payload.code || payload.code === 0) {\n        const item = payload;\n        const index = items.findIndex(it => it.code === item.code);\n\n        if (index === -1) {\n          items.push(item);\n        } else {\n          items[index] = item;\n        }\n      }\n\n      localStorage.setItem(\"items\", JSON.stringify(items));\n      return { ...state,\n        items,\n        saving: false\n      };\n\n    case SAVE_ITEM_FAILED:\n      return { ...state,\n        savingError: payload.error,\n        saving: false\n      };\n\n    default:\n      return state;\n  }\n};\n\nexport const ItemContext = React.createContext(initialState);\nexport const ItemProvider = ({\n  children\n}) => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  let {\n    products,\n    fetching,\n    fetchingError,\n    saving,\n    savingError,\n    page,\n    total,\n    canReDownload,\n    items,\n    uploading,\n    uploadNr\n  } = state;\n  /*  if (!items) {\n      const v = localStorage.getItem(\"items\");\n      items = JSON.parse(v ? v: \"[]\");\n    }*/\n\n  if (!products) {\n    const v = localStorage.getItem(\"products\");\n    products = JSON.parse(v ? v : \"[]\");\n  }\n\n  useEffect(getItemsEffect, []);\n  useEffect(wsEffect, []);\n  const saveItem = useCallback(saveItemCallback, []);\n  const reDownload = useCallback(getItemsEffect, []);\n  const upload = useCallback(uploadItemCallback, []);\n  const value = {\n    products,\n    fetching,\n    fetchingError,\n    saving,\n    savingError,\n    saveItem,\n    page,\n    total,\n    canReDownload,\n    reDownload,\n    items,\n    uploading,\n    uploadNr,\n    upload\n  };\n  log('returns');\n  return /*#__PURE__*/React.createElement(ItemContext.Provider, {\n    value: value,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 138,\n      columnNumber: 5\n    }\n  }, children);\n\n  function getItemsEffect() {\n    let canceled = false;\n    fetchItems();\n    return () => {\n      canceled = true;\n    };\n\n    async function fetchItems() {\n      let page = 0;\n      let pageLocal = localStorage.getItem(\"lastPage\");\n\n      if (pageLocal != null) {\n        page = parseInt(pageLocal);\n      }\n\n      const items = [];\n\n      try {\n        log('fetchItems started');\n        dispatch({\n          type: FETCH_ITEMS_STARTED\n        });\n        log('fetching page', page, 'items', items.length);\n        let fetchedItems = await getProductsPage(page);\n        dispatch({\n          type: PAGE_CHANGED,\n          payload: {\n            page: page,\n            total: fetchedItems.total\n          }\n        });\n\n        while (items.length < fetchedItems.total) {\n          page += 1;\n          log('fetching page', page, 'items', items.length, \"total\", fetchedItems.total);\n          fetchedItems = await getProductsPage(page);\n          dispatch({\n            type: PAGE_CHANGED,\n            payload: {\n              page: page,\n              total: fetchedItems.total\n            }\n          });\n          items.splice(items.length, 0, ...fetchedItems.products);\n        }\n\n        log('fetchItems succeeded');\n\n        if (!canceled) {\n          localStorage.setItem(\"lastPage\", JSON.stringify(page));\n          dispatch({\n            type: FETCH_ITEMS_SUCCEEDED,\n            payload: {\n              items\n            }\n          });\n        }\n      } catch (error) {\n        log('fetchItems failed');\n        dispatch({\n          type: FETCH_ITEMS_FAILED,\n          payload: {\n            error\n          }\n        });\n      }\n    }\n  }\n\n  async function saveItemCallback(item) {\n    log('saveItem started', item);\n    dispatch({\n      type: SAVE_ITEM_SUCCEEDED,\n      payload: item\n    });\n    log('saveItem succeeded');\n  }\n\n  async function uploadItemCallback(items) {\n    let notSubmitted = {\n      code: 0,\n      quantity: 0,\n      submitted: \"not_yet\"\n    };\n\n    try {\n      log('uploadItem started', items);\n\n      if (items) {\n        dispatch({\n          type: UPLOAD_ITEM_STARTED\n        });\n\n        for (const item of items) {\n          item.submitted = \"about_to\";\n          notSubmitted = item;\n          let newItem = item;\n          log('uploading', newItem);\n          await uploadItem(newItem);\n          setTimeout(() => {\n            newItem.submitted = \"yes\";\n            dispatch({\n              type: UPLOADED_ITEM\n            });\n          }, 500);\n        }\n\n        setTimeout(() => {\n          dispatch({\n            type: UPLOAD_ITEM_SUCCEEDED\n          });\n        }, 1000);\n      }\n\n      log('uploadItem succeeded');\n    } catch (error) {\n      log('uploadItem failed');\n      notSubmitted.submitted = \"no\";\n      setTimeout(() => {\n        dispatch({\n          type: UPLOAD_ITEM_FAILED\n        });\n      }, 1000);\n    }\n  }\n\n  function wsEffect() {\n    let canceled = false;\n    log('wsEffect - connecting');\n    const closeWebSocket = newWebSocket(message => {\n      if (canceled) {\n        return;\n      } // const { event, payload: { item }} = message;\n\n\n      log(`ws message, item ${JSON.stringify(message)}`);\n\n      if (message.event === \"productsChanged\") {\n        //getItemsEffect();\n        dispatch({\n          type: CAN_REDOWNLOAD\n        });\n      }\n    });\n    return () => {\n      log('wsEffect - disconnecting');\n      canceled = true;\n      closeWebSocket();\n    };\n  }\n};","map":{"version":3,"sources":["D:/Laboratoare/ANUL 3/Semestrul 1/ProgramarepentruDispozitiveMobile/Examen/Project/src/todo/ItemProvider.tsx"],"names":["React","useCallback","useEffect","useReducer","getLogger","getProductsPage","newWebSocket","uploadItem","log","initialState","fetching","saving","canReDownload","page","total","uploading","uploadNr","FETCH_ITEMS_STARTED","FETCH_ITEMS_SUCCEEDED","FETCH_ITEMS_FAILED","SAVE_ITEM_STARTED","UPLOAD_ITEM_STARTED","UPLOAD_ITEM_SUCCEEDED","UPLOADED_ITEM","UPLOAD_ITEM_FAILED","SAVE_ITEM_SUCCEEDED","SAVE_ITEM_FAILED","PAGE_CHANGED","CAN_REDOWNLOAD","reducer","state","type","payload","fetchingError","localStorage","setItem","JSON","stringify","items","products","error","savingError","code","item","index","findIndex","it","push","ItemContext","createContext","ItemProvider","children","dispatch","v","getItem","parse","getItemsEffect","wsEffect","saveItem","saveItemCallback","reDownload","upload","uploadItemCallback","value","canceled","fetchItems","pageLocal","parseInt","length","fetchedItems","splice","notSubmitted","quantity","submitted","newItem","setTimeout","closeWebSocket","message","event"],"mappings":"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","sourcesContent":["import React, {useCallback, useContext, useEffect, useReducer} from 'react';\nimport PropTypes from 'prop-types';\nimport { getLogger } from '../core';\nimport { ItemProps } from './ItemProps';\nimport { ProductProps } from \"./ProductProps\";\nimport {getProductsPage, newWebSocket, uploadItem} from './itemApi';\n\nconst log = getLogger('ItemProvider');\n\ntype SaveItemFn = (item: ItemProps) => Promise<any>;\ntype ReDownloadFn = () => any;\ntype UploadFn = (items?: ItemProps[]) => any;\n\nexport interface ItemsState {\n  products?: ProductProps[],\n  items?: ItemProps[],\n  canReDownload: boolean,\n  page: number,\n  total: number,\n  fetching: boolean,\n  fetchingError?: Error | null,\n  saving: boolean,\n  savingError?: Error | null,\n  saveItem?: SaveItemFn,\n  reDownload?: ReDownloadFn,\n  upload?: UploadFn,\n  uploading: boolean,\n  uploadNr: number,\n}\n\ninterface ActionProps {\n  type: string,\n  payload?: any,\n}\n\nconst initialState: ItemsState = {\n  fetching: false,\n  saving: false,\n  canReDownload: false,\n  page: 0,\n  total: 0,\n  uploading: false,\n  uploadNr: 0,\n};\n\nconst FETCH_ITEMS_STARTED = 'FETCH_ITEMS_STARTED';\nconst FETCH_ITEMS_SUCCEEDED = 'FETCH_ITEMS_SUCCEEDED';\nconst FETCH_ITEMS_FAILED = 'FETCH_ITEMS_FAILED';\nconst SAVE_ITEM_STARTED = 'SAVE_ITEM_STARTED';\nconst UPLOAD_ITEM_STARTED = 'UPLOAD_ITEM_STARTED';\nconst UPLOAD_ITEM_SUCCEEDED = 'UPLOAD_ITEM_SUCCEEDED';\nconst UPLOADED_ITEM = 'UPLOADED_ITEM';\nconst UPLOAD_ITEM_FAILED = 'UPLOAD_ITEM_FAILED';\nconst SAVE_ITEM_SUCCEEDED = 'SAVE_ITEM_SUCCEEDED';\nconst SAVE_ITEM_FAILED = 'SAVE_ITEM_FAILED';\nconst PAGE_CHANGED = 'PAGE_CHANGED';\nconst CAN_REDOWNLOAD = 'CAN_REDOWNLOAD';\n\nconst reducer: (state: ItemsState, action: ActionProps) => ItemsState =\n  (state, { type, payload }) => {\n    switch (type) {\n      case PAGE_CHANGED:\n        return { ...state, page: payload.page, total: payload.total, canReDownload: false };\n      case CAN_REDOWNLOAD:\n        return { ... state, canReDownload: true};\n      case FETCH_ITEMS_STARTED:\n        return { ...state, fetching: true, fetchingError: null };\n      case FETCH_ITEMS_SUCCEEDED:\n        localStorage.setItem(\"products\", JSON.stringify(payload.items));\n        return { ...state, products: payload.items, fetching: false };\n      case UPLOAD_ITEM_STARTED:\n        return { ...state, uploading: true, uploadNr: 0 };\n      case UPLOAD_ITEM_SUCCEEDED:\n        localStorage.setItem(\"items\", JSON.stringify([]));\n        return { ...state, uploading: false, items: []};\n      case UPLOAD_ITEM_FAILED:\n        return { ... state, uploading: false }\n      case UPLOADED_ITEM:\n        return { ...state, uploadNr: state.uploadNr + 1 }\n      case FETCH_ITEMS_FAILED:\n        return { ...state, fetchingError: payload.error, fetching: false, canReDownload: true };\n      case SAVE_ITEM_STARTED:\n        return { ...state, savingError: null, saving: true };\n      case SAVE_ITEM_SUCCEEDED:\n        const items = [...(state.items || [])];\n        //const item = payload.item;\n        if (payload.code || payload.code === 0) {\n          const item = payload;\n          const index = items.findIndex(it => it.code === item.code);\n          if (index === -1) {\n            items.push(item);\n          } else {\n            items[index] = item;\n          }\n        }\n        localStorage.setItem(\"items\", JSON.stringify(items));\n        return { ...state, items, saving: false };\n      case SAVE_ITEM_FAILED:\n        return { ...state, savingError: payload.error, saving: false };\n\n\n      default:\n        return state;\n    }\n  };\n\nexport const ItemContext = React.createContext<ItemsState>(initialState);\n\ninterface ItemProviderProps {\n  children: PropTypes.ReactNodeLike,\n}\n\nexport const ItemProvider: React.FC<ItemProviderProps> = ({ children }) => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  let { products, fetching, fetchingError, saving, savingError, page, total, canReDownload, items, uploading, uploadNr } = state;\n\n/*  if (!items) {\n    const v = localStorage.getItem(\"items\");\n    items = JSON.parse(v ? v: \"[]\");\n  }*/\n\n  if(!products) {\n    const v = localStorage.getItem(\"products\")\n    products = JSON.parse(v ? v: \"[]\")\n  }\n\n  useEffect(getItemsEffect, []);\n  useEffect(wsEffect, []);\n\n  const saveItem = useCallback<SaveItemFn>(saveItemCallback, []);\n  const reDownload = useCallback<ReDownloadFn>(getItemsEffect, []);\n  const upload = useCallback<UploadFn>(uploadItemCallback, []);\n\n  const value = { products, fetching, fetchingError, saving, savingError, saveItem, page, total, canReDownload, reDownload, items, uploading, uploadNr, upload };\n\n  log('returns');\n  return (\n    <ItemContext.Provider value={value}>\n      {children}\n    </ItemContext.Provider>\n  );\n\n  function getItemsEffect() {\n    let canceled = false;\n    fetchItems();\n\n    return () => {\n      canceled = true;\n    }\n\n    async function fetchItems() {\n      let page = 0;\n      let pageLocal = localStorage.getItem(\"lastPage\");\n      if(pageLocal != null)\n      {\n        page = parseInt(pageLocal);\n      }\n      const items: ProductProps[] = [];\n      try {\n        log('fetchItems started');\n        dispatch({ type: FETCH_ITEMS_STARTED });\n\n        log('fetching page', page, 'items', items.length);\n        let fetchedItems = await getProductsPage(page);\n        dispatch({type: PAGE_CHANGED, payload: {page: page, total: fetchedItems.total}});\n\n        while (items.length < fetchedItems.total) {\n          page += 1;\n          log('fetching page', page, 'items', items.length, \"total\", fetchedItems.total);\n          fetchedItems = await getProductsPage(page);\n          dispatch({type: PAGE_CHANGED, payload: {page: page, total: fetchedItems.total}});\n          items.splice(items.length, 0, ...fetchedItems.products)\n        }\n\n        log('fetchItems succeeded');\n        if (!canceled) {\n          localStorage.setItem(\"lastPage\", JSON.stringify(page))\n          dispatch({ type: FETCH_ITEMS_SUCCEEDED, payload: { items } });\n        }\n      } catch (error) {\n        log('fetchItems failed');\n        dispatch({ type: FETCH_ITEMS_FAILED, payload: { error } });\n      }\n    }\n  }\n\n  async function saveItemCallback(item: ItemProps) {\n    log('saveItem started', item);\n    dispatch({ type: SAVE_ITEM_SUCCEEDED, payload: item });\n    log('saveItem succeeded');\n  }\n\n  async function uploadItemCallback(items?: ItemProps[]) {\n    let notSubmitted: ItemProps = (({code: 0, quantity: 0, submitted: \"not_yet\"}));\n    try {\n      log('uploadItem started', items);\n      if (items) {\n        dispatch({ type: UPLOAD_ITEM_STARTED });\n        for (const item of items) {\n          item.submitted = \"about_to\";\n          notSubmitted = item;\n          let newItem: ItemProps = item;\n          log('uploading', newItem);\n          await uploadItem(newItem);\n          setTimeout(() => {newItem.submitted = \"yes\";dispatch({ type: UPLOADED_ITEM});}, 500);\n        }\n        setTimeout(() => {dispatch({ type: UPLOAD_ITEM_SUCCEEDED});}, 1000);\n      }\n      log('uploadItem succeeded');\n    } catch (error) {\n      log('uploadItem failed');\n      notSubmitted.submitted = \"no\";\n      setTimeout(() => {      dispatch({ type: UPLOAD_ITEM_FAILED});}, 1000);\n    }\n  }\n\n  function wsEffect() {\n    let canceled = false;\n    log('wsEffect - connecting');\n    const closeWebSocket = newWebSocket(message => {\n      if (canceled) {\n        return;\n      }\n      // const { event, payload: { item }} = message;\n      log(`ws message, item ${JSON.stringify(message)}`);\n      if (message.event === \"productsChanged\") {\n        //getItemsEffect();\n        dispatch({ type: CAN_REDOWNLOAD });\n      }\n    });\n    return () => {\n      log('wsEffect - disconnecting');\n      canceled = true;\n      closeWebSocket();\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"module"}