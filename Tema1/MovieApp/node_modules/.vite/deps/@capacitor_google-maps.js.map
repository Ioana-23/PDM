{
  "version": 3,
  "sources": ["../../@capacitor/google-maps/src/map.ts"],
  "sourcesContent": ["import { Capacitor } from '@capacitor/core';\nimport type { PluginListenerHandle } from '@capacitor/core';\n\nimport type {\n  CameraConfig,\n  Marker,\n  MapPadding,\n  MapListenerCallback,\n  MapReadyCallbackData,\n  CameraIdleCallbackData,\n  CameraMoveStartedCallbackData,\n  ClusterClickCallbackData,\n  MapClickCallbackData,\n  MarkerClickCallbackData,\n  MyLocationButtonClickCallbackData,\n  Polygon,\n  PolygonClickCallbackData,\n  Circle,\n  CircleClickCallbackData,\n  Polyline,\n  PolylineCallbackData,\n} from './definitions';\nimport { LatLngBounds, MapType } from './definitions';\nimport type { CreateMapArgs } from './implementation';\nimport { CapacitorGoogleMaps } from './implementation';\n\nexport interface GoogleMapInterface {\n  create(\n    options: CreateMapArgs,\n    callback?: MapListenerCallback<MapReadyCallbackData>,\n  ): Promise<GoogleMap>;\n  enableTouch(): Promise<void>;\n  disableTouch(): Promise<void>;\n  enableClustering(\n    /**\n     * The minimum number of markers that can be clustered together. The default is 4 markers.\n     */\n    minClusterSize?: number,\n  ): Promise<void>;\n  disableClustering(): Promise<void>;\n  addMarker(marker: Marker): Promise<string>;\n  addMarkers(markers: Marker[]): Promise<string[]>;\n  removeMarker(id: string): Promise<void>;\n  removeMarkers(ids: string[]): Promise<void>;\n  addPolygons(polygons: Polygon[]): Promise<string[]>;\n  removePolygons(ids: string[]): Promise<void>;\n  addCircles(circles: Circle[]): Promise<string[]>;\n  removeCircles(ids: string[]): Promise<void>;\n  addPolylines(polylines: Polyline[]): Promise<string[]>;\n  removePolylines(ids: string[]): Promise<void>;\n  destroy(): Promise<void>;\n  setCamera(config: CameraConfig): Promise<void>;\n  /**\n   * Get current map type\n   */\n  getMapType(): Promise<MapType>;\n  setMapType(mapType: MapType): Promise<void>;\n  enableIndoorMaps(enabled: boolean): Promise<void>;\n  enableTrafficLayer(enabled: boolean): Promise<void>;\n  enableAccessibilityElements(enabled: boolean): Promise<void>;\n  enableCurrentLocation(enabled: boolean): Promise<void>;\n  setPadding(padding: MapPadding): Promise<void>;\n  /**\n   * Sets the map viewport to contain the given bounds.\n   * @param bounds The bounds to fit in the viewport.\n   * @param padding Optional padding to apply in pixels. The bounds will be fit in the part of the map that remains after padding is removed.\n   */\n  fitBounds(bounds: LatLngBounds, padding?: number): Promise<void>;\n  setOnBoundsChangedListener(\n    callback?: MapListenerCallback<CameraIdleCallbackData>,\n  ): Promise<void>;\n  setOnCameraIdleListener(\n    callback?: MapListenerCallback<CameraIdleCallbackData>,\n  ): Promise<void>;\n  setOnCameraMoveStartedListener(\n    callback?: MapListenerCallback<CameraMoveStartedCallbackData>,\n  ): Promise<void>;\n  setOnClusterClickListener(\n    callback?: MapListenerCallback<ClusterClickCallbackData>,\n  ): Promise<void>;\n  setOnClusterInfoWindowClickListener(\n    callback?: MapListenerCallback<ClusterClickCallbackData>,\n  ): Promise<void>;\n  setOnInfoWindowClickListener(\n    callback?: MapListenerCallback<MarkerClickCallbackData>,\n  ): Promise<void>;\n  setOnMapClickListener(\n    callback?: MapListenerCallback<MapClickCallbackData>,\n  ): Promise<void>;\n  setOnMarkerClickListener(\n    callback?: MapListenerCallback<MarkerClickCallbackData>,\n  ): Promise<void>;\n  setOnPolygonClickListener(\n    callback?: MapListenerCallback<PolygonClickCallbackData>,\n  ): Promise<void>;\n  setOnCircleClickListener(\n    callback?: MapListenerCallback<CircleClickCallbackData>,\n  ): Promise<void>;\n  setOnPolylineClickListener(\n    callback?: MapListenerCallback<PolylineCallbackData>,\n  ): Promise<void>;\n  setOnMarkerDragStartListener(\n    callback?: MapListenerCallback<MarkerClickCallbackData>,\n  ): Promise<void>;\n  setOnMarkerDragListener(\n    callback?: MapListenerCallback<MarkerClickCallbackData>,\n  ): Promise<void>;\n  setOnMarkerDragEndListener(\n    callback?: MapListenerCallback<MarkerClickCallbackData>,\n  ): Promise<void>;\n  setOnMyLocationButtonClickListener(\n    callback?: MapListenerCallback<MyLocationButtonClickCallbackData>,\n  ): Promise<void>;\n  setOnMyLocationClickListener(\n    callback?: MapListenerCallback<MapClickCallbackData>,\n  ): Promise<void>;\n}\n\nclass MapCustomElement extends HTMLElement {\n  constructor() {\n    super();\n  }\n\n  connectedCallback() {\n    this.innerHTML = '';\n\n    if (Capacitor.getPlatform() == 'ios') {\n      this.style.overflow = 'scroll';\n      (this.style as any)['-webkit-overflow-scrolling'] = 'touch';\n\n      const overflowDiv = document.createElement('div');\n      overflowDiv.style.height = '200%';\n\n      this.appendChild(overflowDiv);\n    }\n  }\n}\n\ncustomElements.define('capacitor-google-map', MapCustomElement);\n\nexport class GoogleMap {\n  private id: string;\n  private element: HTMLElement | null = null;\n  private resizeObserver: ResizeObserver | null = null;\n\n  private onBoundsChangedListener?: PluginListenerHandle;\n  private onCameraIdleListener?: PluginListenerHandle;\n  private onCameraMoveStartedListener?: PluginListenerHandle;\n  private onClusterClickListener?: PluginListenerHandle;\n  private onClusterInfoWindowClickListener?: PluginListenerHandle;\n  private onInfoWindowClickListener?: PluginListenerHandle;\n  private onMapClickListener?: PluginListenerHandle;\n  private onPolylineClickListener?: PluginListenerHandle;\n  private onMarkerClickListener?: PluginListenerHandle;\n  private onPolygonClickListener?: PluginListenerHandle;\n  private onCircleClickListener?: PluginListenerHandle;\n  private onMarkerDragStartListener?: PluginListenerHandle;\n  private onMarkerDragListener?: PluginListenerHandle;\n  private onMarkerDragEndListener?: PluginListenerHandle;\n  private onMyLocationButtonClickListener?: PluginListenerHandle;\n  private onMyLocationClickListener?: PluginListenerHandle;\n\n  private constructor(id: string) {\n    this.id = id;\n  }\n\n  /**\n   * Creates a new instance of a Google Map\n   * @param options\n   * @param callback\n   * @returns GoogleMap\n   */\n  public static async create(\n    options: CreateMapArgs,\n    callback?: MapListenerCallback<MapReadyCallbackData>,\n  ): Promise<GoogleMap> {\n    const newMap = new GoogleMap(options.id);\n\n    if (!options.element) {\n      throw new Error('container element is required');\n    }\n\n    if (options.config.androidLiteMode === undefined) {\n      options.config.androidLiteMode = false;\n    }\n\n    newMap.element = options.element;\n    newMap.element.dataset.internalId = options.id;\n\n    const elementBounds = await GoogleMap.getElementBounds(options.element);\n    options.config.width = elementBounds.width;\n    options.config.height = elementBounds.height;\n    options.config.x = elementBounds.x;\n    options.config.y = elementBounds.y;\n    options.config.devicePixelRatio = window.devicePixelRatio;\n\n    if (Capacitor.getPlatform() == 'android') {\n      newMap.initScrolling();\n    }\n\n    if (Capacitor.isNativePlatform()) {\n      (options.element as any) = {};\n\n      const getMapBounds = () => {\n        const mapRect =\n          newMap.element?.getBoundingClientRect() ?? ({} as DOMRect);\n        return {\n          x: mapRect.x,\n          y: mapRect.y,\n          width: mapRect.width,\n          height: mapRect.height,\n        };\n      };\n\n      const onDisplay = () => {\n        CapacitorGoogleMaps.onDisplay({\n          id: newMap.id,\n          mapBounds: getMapBounds(),\n        });\n      };\n\n      const onResize = () => {\n        CapacitorGoogleMaps.onResize({\n          id: newMap.id,\n          mapBounds: getMapBounds(),\n        });\n      };\n\n      const ionicPage = newMap.element.closest('.ion-page');\n      if (Capacitor.getPlatform() === 'ios' && ionicPage) {\n        ionicPage.addEventListener('ionViewWillEnter', () => {\n          setTimeout(() => {\n            onDisplay();\n          }, 100);\n        });\n        ionicPage.addEventListener('ionViewDidEnter', () => {\n          setTimeout(() => {\n            onDisplay();\n          }, 100);\n        });\n      }\n\n      const lastState = {\n        width: elementBounds.width,\n        height: elementBounds.height,\n        isHidden: false,\n      };\n      newMap.resizeObserver = new ResizeObserver(() => {\n        if (newMap.element != null) {\n          const mapRect = newMap.element.getBoundingClientRect();\n\n          const isHidden = mapRect.width === 0 && mapRect.height === 0;\n          if (!isHidden) {\n            if (lastState.isHidden) {\n              if (Capacitor.getPlatform() === 'ios' && !ionicPage) {\n                onDisplay();\n              }\n            } else if (\n              lastState.width !== mapRect.width ||\n              lastState.height !== mapRect.height\n            ) {\n              onResize();\n            }\n          }\n\n          lastState.width = mapRect.width;\n          lastState.height = mapRect.height;\n          lastState.isHidden = isHidden;\n        }\n      });\n      newMap.resizeObserver.observe(newMap.element);\n    }\n\n    // small delay to allow for iOS WKWebView to setup corresponding element sub-scroll views ???\n    await new Promise((resolve, reject) => {\n      setTimeout(async () => {\n        try {\n          await CapacitorGoogleMaps.create(options);\n          resolve(undefined);\n        } catch (err) {\n          reject(err);\n        }\n      }, 200);\n    });\n\n    if (callback) {\n      const onMapReadyListener = await CapacitorGoogleMaps.addListener(\n        'onMapReady',\n        (data: MapReadyCallbackData) => {\n          if (data.mapId == newMap.id) {\n            callback(data);\n            onMapReadyListener.remove();\n          }\n        },\n      );\n    }\n\n    return newMap;\n  }\n\n  private static async getElementBounds(\n    element: HTMLElement,\n  ): Promise<DOMRect> {\n    return new Promise(resolve => {\n      let elementBounds = element.getBoundingClientRect();\n      if (elementBounds.width == 0) {\n        let retries = 0;\n        const boundsInterval = setInterval(function () {\n          if (elementBounds.width == 0 && retries < 30) {\n            elementBounds = element.getBoundingClientRect();\n            retries++;\n          } else {\n            if (retries == 30) {\n              console.warn('Map size could not be determined');\n            }\n            clearInterval(boundsInterval);\n            resolve(elementBounds);\n          }\n        }, 100);\n      } else {\n        resolve(elementBounds);\n      }\n    });\n  }\n\n  /**\n   * Enable touch events on native map\n   *\n   * @returns void\n   */\n  async enableTouch(): Promise<void> {\n    return CapacitorGoogleMaps.enableTouch({\n      id: this.id,\n    });\n  }\n\n  /**\n   * Disable touch events on native map\n   *\n   * @returns void\n   */\n  async disableTouch(): Promise<void> {\n    return CapacitorGoogleMaps.disableTouch({\n      id: this.id,\n    });\n  }\n\n  /**\n   * Enable marker clustering\n   *\n   * @param minClusterSize - The minimum number of markers that can be clustered together.\n   * @defaultValue 4\n   *\n   * @returns void\n   */\n  async enableClustering(minClusterSize?: number): Promise<void> {\n    return CapacitorGoogleMaps.enableClustering({\n      id: this.id,\n      minClusterSize,\n    });\n  }\n\n  /**\n   * Disable marker clustering\n   *\n   * @returns void\n   */\n  async disableClustering(): Promise<void> {\n    return CapacitorGoogleMaps.disableClustering({\n      id: this.id,\n    });\n  }\n\n  /**\n   * Adds a marker to the map\n   *\n   * @param marker\n   * @returns created marker id\n   */\n  async addMarker(marker: Marker): Promise<string> {\n    const res = await CapacitorGoogleMaps.addMarker({\n      id: this.id,\n      marker,\n    });\n\n    return res.id;\n  }\n\n  /**\n   * Adds multiple markers to the map\n   *\n   * @param markers\n   * @returns array of created marker IDs\n   */\n  async addMarkers(markers: Marker[]): Promise<string[]> {\n    const res = await CapacitorGoogleMaps.addMarkers({\n      id: this.id,\n      markers,\n    });\n\n    return res.ids;\n  }\n\n  /**\n   * Remove marker from the map\n   *\n   * @param id id of the marker to remove from the map\n   * @returns\n   */\n  async removeMarker(id: string): Promise<void> {\n    return CapacitorGoogleMaps.removeMarker({\n      id: this.id,\n      markerId: id,\n    });\n  }\n\n  /**\n   * Remove markers from the map\n   *\n   * @param ids array of ids to remove from the map\n   * @returns\n   */\n  async removeMarkers(ids: string[]): Promise<void> {\n    return CapacitorGoogleMaps.removeMarkers({\n      id: this.id,\n      markerIds: ids,\n    });\n  }\n\n  async addPolygons(polygons: Polygon[]): Promise<string[]> {\n    const res = await CapacitorGoogleMaps.addPolygons({\n      id: this.id,\n      polygons,\n    });\n\n    return res.ids;\n  }\n\n  async addPolylines(polylines: Polyline[]): Promise<string[]> {\n    const res = await CapacitorGoogleMaps.addPolylines({\n      id: this.id,\n      polylines,\n    });\n\n    return res.ids;\n  }\n\n  async removePolygons(ids: string[]): Promise<void> {\n    return CapacitorGoogleMaps.removePolygons({\n      id: this.id,\n      polygonIds: ids,\n    });\n  }\n\n  async addCircles(circles: Circle[]): Promise<string[]> {\n    const res = await CapacitorGoogleMaps.addCircles({\n      id: this.id,\n      circles,\n    });\n\n    return res.ids;\n  }\n\n  async removeCircles(ids: string[]): Promise<void> {\n    return CapacitorGoogleMaps.removeCircles({\n      id: this.id,\n      circleIds: ids,\n    });\n  }\n\n  async removePolylines(ids: string[]): Promise<void> {\n    return CapacitorGoogleMaps.removePolylines({\n      id: this.id,\n      polylineIds: ids,\n    });\n  }\n\n  /**\n   * Destroy the current instance of the map\n   */\n  async destroy(): Promise<void> {\n    if (Capacitor.getPlatform() == 'android') {\n      this.disableScrolling();\n    }\n\n    if (Capacitor.isNativePlatform()) {\n      this.resizeObserver?.disconnect();\n    }\n\n    this.removeAllMapListeners();\n\n    return CapacitorGoogleMaps.destroy({\n      id: this.id,\n    });\n  }\n\n  /**\n   * Update the map camera configuration\n   *\n   * @param config\n   * @returns\n   */\n  async setCamera(config: CameraConfig): Promise<void> {\n    return CapacitorGoogleMaps.setCamera({\n      id: this.id,\n      config,\n    });\n  }\n\n  async getMapType(): Promise<MapType> {\n    const { type } = await CapacitorGoogleMaps.getMapType({ id: this.id });\n    return MapType[type as keyof typeof MapType];\n  }\n\n  /**\n   * Sets the type of map tiles that should be displayed.\n   *\n   * @param mapType\n   * @returns\n   */\n  async setMapType(mapType: MapType): Promise<void> {\n    return CapacitorGoogleMaps.setMapType({\n      id: this.id,\n      mapType,\n    });\n  }\n\n  /**\n   * Sets whether indoor maps are shown, where available.\n   *\n   * @param enabled\n   * @returns\n   */\n  async enableIndoorMaps(enabled: boolean): Promise<void> {\n    return CapacitorGoogleMaps.enableIndoorMaps({\n      id: this.id,\n      enabled,\n    });\n  }\n\n  /**\n   * Controls whether the map is drawing traffic data, if available.\n   *\n   * @param enabled\n   * @returns\n   */\n  async enableTrafficLayer(enabled: boolean): Promise<void> {\n    return CapacitorGoogleMaps.enableTrafficLayer({\n      id: this.id,\n      enabled,\n    });\n  }\n\n  /**\n   * Show accessibility elements for overlay objects, such as Marker and Polyline.\n   *\n   * Only available on iOS.\n   *\n   * @param enabled\n   * @returns\n   */\n  async enableAccessibilityElements(enabled: boolean): Promise<void> {\n    return CapacitorGoogleMaps.enableAccessibilityElements({\n      id: this.id,\n      enabled,\n    });\n  }\n\n  /**\n   * Set whether the My Location dot and accuracy circle is enabled.\n   *\n   * @param enabled\n   * @returns\n   */\n  async enableCurrentLocation(enabled: boolean): Promise<void> {\n    return CapacitorGoogleMaps.enableCurrentLocation({\n      id: this.id,\n      enabled,\n    });\n  }\n\n  /**\n   * Set padding on the 'visible' region of the view.\n   *\n   * @param padding\n   * @returns\n   */\n  async setPadding(padding: MapPadding): Promise<void> {\n    return CapacitorGoogleMaps.setPadding({\n      id: this.id,\n      padding,\n    });\n  }\n\n  /**\n   * Get the map's current viewport latitude and longitude bounds.\n   *\n   * @returns {LatLngBounds}\n   */\n  async getMapBounds(): Promise<LatLngBounds> {\n    return new LatLngBounds(\n      await CapacitorGoogleMaps.getMapBounds({\n        id: this.id,\n      }),\n    );\n  }\n\n  async fitBounds(bounds: LatLngBounds, padding?: number): Promise<void> {\n    return CapacitorGoogleMaps.fitBounds({\n      id: this.id,\n      bounds,\n      padding,\n    });\n  }\n\n  initScrolling(): void {\n    const ionContents = document.getElementsByTagName('ion-content');\n\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < ionContents.length; i++) {\n      (ionContents[i] as any).scrollEvents = true;\n    }\n\n    window.addEventListener('ionScroll', this.handleScrollEvent);\n    window.addEventListener('scroll', this.handleScrollEvent);\n    window.addEventListener('resize', this.handleScrollEvent);\n    if (screen.orientation) {\n      screen.orientation.addEventListener('change', () => {\n        setTimeout(this.updateMapBounds, 500);\n      });\n    } else {\n      window.addEventListener('orientationchange', () => {\n        setTimeout(this.updateMapBounds, 500);\n      });\n    }\n  }\n\n  disableScrolling(): void {\n    window.removeEventListener('ionScroll', this.handleScrollEvent);\n    window.removeEventListener('scroll', this.handleScrollEvent);\n    window.removeEventListener('resize', this.handleScrollEvent);\n    if (screen.orientation) {\n      screen.orientation.removeEventListener('change', () => {\n        setTimeout(this.updateMapBounds, 1000);\n      });\n    } else {\n      window.removeEventListener('orientationchange', () => {\n        setTimeout(this.updateMapBounds, 1000);\n      });\n    }\n  }\n\n  handleScrollEvent = (): void => this.updateMapBounds();\n\n  private updateMapBounds(): void {\n    if (this.element) {\n      const mapRect = this.element.getBoundingClientRect();\n\n      CapacitorGoogleMaps.onScroll({\n        id: this.id,\n        mapBounds: {\n          x: mapRect.x,\n          y: mapRect.y,\n          width: mapRect.width,\n          height: mapRect.height,\n        },\n      });\n    }\n  }\n\n  /*\n  private findContainerElement(): HTMLElement | null {\n    if (!this.element) {\n      return null;\n    }\n\n    let parentElement = this.element.parentElement;\n    while (parentElement !== null) {\n      if (window.getComputedStyle(parentElement).overflowY !== 'hidden') {\n        return parentElement;\n      }\n\n      parentElement = parentElement.parentElement;\n    }\n\n    return null;\n  }\n  */\n\n  /**\n   * Set the event listener on the map for 'onCameraIdle' events.\n   *\n   * @param callback\n   * @returns\n   */\n  async setOnCameraIdleListener(\n    callback?: MapListenerCallback<CameraIdleCallbackData>,\n  ): Promise<void> {\n    if (this.onCameraIdleListener) {\n      this.onCameraIdleListener.remove();\n    }\n\n    if (callback) {\n      this.onCameraIdleListener = await CapacitorGoogleMaps.addListener(\n        'onCameraIdle',\n        this.generateCallback(callback),\n      );\n    } else {\n      this.onCameraIdleListener = undefined;\n    }\n  }\n\n  /**\n   * Set the event listener on the map for 'onBoundsChanged' events.\n   *\n   * @param callback\n   * @returns\n   */\n  async setOnBoundsChangedListener(\n    callback?: MapListenerCallback<CameraIdleCallbackData>,\n  ): Promise<void> {\n    if (this.onBoundsChangedListener) {\n      this.onBoundsChangedListener.remove();\n    }\n\n    if (callback) {\n      this.onBoundsChangedListener = await CapacitorGoogleMaps.addListener(\n        'onBoundsChanged',\n        this.generateCallback(callback),\n      );\n    } else {\n      this.onBoundsChangedListener = undefined;\n    }\n  }\n\n  /**\n   * Set the event listener on the map for 'onCameraMoveStarted' events.\n   *\n   * @param callback\n   * @returns\n   */\n  async setOnCameraMoveStartedListener(\n    callback?: MapListenerCallback<CameraMoveStartedCallbackData>,\n  ): Promise<void> {\n    if (this.onCameraMoveStartedListener) {\n      this.onCameraMoveStartedListener.remove();\n    }\n\n    if (callback) {\n      this.onCameraMoveStartedListener = await CapacitorGoogleMaps.addListener(\n        'onCameraMoveStarted',\n        this.generateCallback(callback),\n      );\n    } else {\n      this.onCameraMoveStartedListener = undefined;\n    }\n  }\n\n  /**\n   * Set the event listener on the map for 'onClusterClick' events.\n   *\n   * @param callback\n   * @returns\n   */\n  async setOnClusterClickListener(\n    callback?: MapListenerCallback<ClusterClickCallbackData>,\n  ): Promise<void> {\n    if (this.onClusterClickListener) {\n      this.onClusterClickListener.remove();\n    }\n\n    if (callback) {\n      this.onClusterClickListener = await CapacitorGoogleMaps.addListener(\n        'onClusterClick',\n        this.generateCallback(callback),\n      );\n    } else {\n      this.onClusterClickListener = undefined;\n    }\n  }\n\n  /**\n   * Set the event listener on the map for 'onClusterInfoWindowClick' events.\n   *\n   * @param callback\n   * @returns\n   */\n  async setOnClusterInfoWindowClickListener(\n    callback?: MapListenerCallback<ClusterClickCallbackData>,\n  ): Promise<void> {\n    if (this.onClusterInfoWindowClickListener) {\n      this.onClusterInfoWindowClickListener.remove();\n    }\n\n    if (callback) {\n      this.onClusterInfoWindowClickListener =\n        await CapacitorGoogleMaps.addListener(\n          'onClusterInfoWindowClick',\n          this.generateCallback(callback),\n        );\n    } else {\n      this.onClusterInfoWindowClickListener = undefined;\n    }\n  }\n\n  /**\n   * Set the event listener on the map for 'onInfoWindowClick' events.\n   *\n   * @param callback\n   * @returns\n   */\n  async setOnInfoWindowClickListener(\n    callback?: MapListenerCallback<MarkerClickCallbackData>,\n  ): Promise<void> {\n    if (this.onInfoWindowClickListener) {\n      this.onInfoWindowClickListener.remove();\n    }\n\n    if (callback) {\n      this.onInfoWindowClickListener = await CapacitorGoogleMaps.addListener(\n        'onInfoWindowClick',\n        this.generateCallback(callback),\n      );\n    } else {\n      this.onInfoWindowClickListener = undefined;\n    }\n  }\n\n  /**\n   * Set the event listener on the map for 'onMapClick' events.\n   *\n   * @param callback\n   * @returns\n   */\n  async setOnMapClickListener(\n    callback?: MapListenerCallback<MapClickCallbackData>,\n  ): Promise<void> {\n    if (this.onMapClickListener) {\n      this.onMapClickListener.remove();\n    }\n\n    if (callback) {\n      this.onMapClickListener = await CapacitorGoogleMaps.addListener(\n        'onMapClick',\n        this.generateCallback(callback),\n      );\n    } else {\n      this.onMapClickListener = undefined;\n    }\n  }\n\n  /**\n   * Set the event listener on the map for 'onPolygonClick' events.\n   *\n   * @param callback\n   * @returns\n   */\n  async setOnPolygonClickListener(\n    callback?: MapListenerCallback<PolygonClickCallbackData>,\n  ): Promise<void> {\n    if (this.onPolygonClickListener) {\n      this.onPolygonClickListener.remove();\n    }\n\n    if (callback) {\n      this.onPolygonClickListener = await CapacitorGoogleMaps.addListener(\n        'onPolygonClick',\n        this.generateCallback(callback),\n      );\n    } else {\n      this.onPolygonClickListener = undefined;\n    }\n  }\n\n  /**\n   * Set the event listener on the map for 'onCircleClick' events.\n   *\n   * @param callback\n   * @returns\n   */\n  async setOnCircleClickListener(\n    callback?: MapListenerCallback<CircleClickCallbackData>,\n  ): Promise<void> {\n    if (this.onCircleClickListener) [this.onCircleClickListener.remove()];\n\n    if (callback) {\n      this.onCircleClickListener = await CapacitorGoogleMaps.addListener(\n        'onCircleClick',\n        this.generateCallback(callback),\n      );\n    } else {\n      this.onCircleClickListener = undefined;\n    }\n  }\n\n  /**\n   * Set the event listener on the map for 'onMarkerClick' events.\n   *\n   * @param callback\n   * @returns\n   */\n  async setOnMarkerClickListener(\n    callback?: MapListenerCallback<MarkerClickCallbackData>,\n  ): Promise<void> {\n    if (this.onMarkerClickListener) {\n      this.onMarkerClickListener.remove();\n    }\n\n    if (callback) {\n      this.onMarkerClickListener = await CapacitorGoogleMaps.addListener(\n        'onMarkerClick',\n        this.generateCallback(callback),\n      );\n    } else {\n      this.onMarkerClickListener = undefined;\n    }\n  }\n  /**\n   * Set the event listener on the map for 'onPolylineClick' events.\n   *\n   * @param callback\n   * @returns\n   */\n  async setOnPolylineClickListener(\n    callback?: MapListenerCallback<PolylineCallbackData>,\n  ): Promise<void> {\n    if (this.onPolylineClickListener) {\n      this.onPolylineClickListener.remove();\n    }\n\n    if (callback) {\n      this.onPolylineClickListener = await CapacitorGoogleMaps.addListener(\n        'onPolylineClick',\n        this.generateCallback(callback),\n      );\n    } else {\n      this.onPolylineClickListener = undefined;\n    }\n  }\n\n  /**\n   * Set the event listener on the map for 'onMarkerDragStart' events.\n   *\n   * @param callback\n   * @returns\n   */\n  async setOnMarkerDragStartListener(\n    callback?: MapListenerCallback<MarkerClickCallbackData>,\n  ): Promise<void> {\n    if (this.onMarkerDragStartListener) {\n      this.onMarkerDragStartListener.remove();\n    }\n\n    if (callback) {\n      this.onMarkerDragStartListener = await CapacitorGoogleMaps.addListener(\n        'onMarkerDragStart',\n        this.generateCallback(callback),\n      );\n    } else {\n      this.onMarkerDragStartListener = undefined;\n    }\n  }\n\n  /**\n   * Set the event listener on the map for 'onMarkerDrag' events.\n   *\n   * @param callback\n   * @returns\n   */\n  async setOnMarkerDragListener(\n    callback?: MapListenerCallback<MarkerClickCallbackData>,\n  ): Promise<void> {\n    if (this.onMarkerDragListener) {\n      this.onMarkerDragListener.remove();\n    }\n\n    if (callback) {\n      this.onMarkerDragListener = await CapacitorGoogleMaps.addListener(\n        'onMarkerDrag',\n        this.generateCallback(callback),\n      );\n    } else {\n      this.onMarkerDragListener = undefined;\n    }\n  }\n\n  /**\n   * Set the event listener on the map for 'onMarkerDragEnd' events.\n   *\n   * @param callback\n   * @returns\n   */\n  async setOnMarkerDragEndListener(\n    callback?: MapListenerCallback<MarkerClickCallbackData>,\n  ): Promise<void> {\n    if (this.onMarkerDragEndListener) {\n      this.onMarkerDragEndListener.remove();\n    }\n\n    if (callback) {\n      this.onMarkerDragEndListener = await CapacitorGoogleMaps.addListener(\n        'onMarkerDragEnd',\n        this.generateCallback(callback),\n      );\n    } else {\n      this.onMarkerDragEndListener = undefined;\n    }\n  }\n\n  /**\n   * Set the event listener on the map for 'onMyLocationButtonClick' events.\n   *\n   * @param callback\n   * @returns\n   */\n  async setOnMyLocationButtonClickListener(\n    callback?: MapListenerCallback<MyLocationButtonClickCallbackData>,\n  ): Promise<void> {\n    if (this.onMyLocationButtonClickListener) {\n      this.onMyLocationButtonClickListener.remove();\n    }\n\n    if (callback) {\n      this.onMyLocationButtonClickListener =\n        await CapacitorGoogleMaps.addListener(\n          'onMyLocationButtonClick',\n          this.generateCallback(callback),\n        );\n    } else {\n      this.onMyLocationButtonClickListener = undefined;\n    }\n  }\n\n  /**\n   * Set the event listener on the map for 'onMyLocationClick' events.\n   *\n   * @param callback\n   * @returns\n   */\n  async setOnMyLocationClickListener(\n    callback?: MapListenerCallback<MapClickCallbackData>,\n  ): Promise<void> {\n    if (this.onMyLocationClickListener) {\n      this.onMyLocationClickListener.remove();\n    }\n\n    if (callback) {\n      this.onMyLocationClickListener = await CapacitorGoogleMaps.addListener(\n        'onMyLocationClick',\n        this.generateCallback(callback),\n      );\n    } else {\n      this.onMyLocationClickListener = undefined;\n    }\n  }\n\n  /**\n   * Remove all event listeners on the map.\n   *\n   * @param callback\n   * @returns\n   */\n  async removeAllMapListeners(): Promise<void> {\n    if (this.onBoundsChangedListener) {\n      this.onBoundsChangedListener.remove();\n      this.onBoundsChangedListener = undefined;\n    }\n    if (this.onCameraIdleListener) {\n      this.onCameraIdleListener.remove();\n      this.onCameraIdleListener = undefined;\n    }\n    if (this.onCameraMoveStartedListener) {\n      this.onCameraMoveStartedListener.remove();\n      this.onCameraMoveStartedListener = undefined;\n    }\n\n    if (this.onClusterClickListener) {\n      this.onClusterClickListener.remove();\n      this.onClusterClickListener = undefined;\n    }\n\n    if (this.onClusterInfoWindowClickListener) {\n      this.onClusterInfoWindowClickListener.remove();\n      this.onClusterInfoWindowClickListener = undefined;\n    }\n\n    if (this.onInfoWindowClickListener) {\n      this.onInfoWindowClickListener.remove();\n      this.onInfoWindowClickListener = undefined;\n    }\n\n    if (this.onMapClickListener) {\n      this.onMapClickListener.remove();\n      this.onMapClickListener = undefined;\n    }\n\n    if (this.onPolylineClickListener) {\n      this.onPolylineClickListener.remove();\n      this.onPolylineClickListener = undefined;\n    }\n\n    if (this.onMarkerClickListener) {\n      this.onMarkerClickListener.remove();\n      this.onMarkerClickListener = undefined;\n    }\n\n    if (this.onPolygonClickListener) {\n      this.onPolygonClickListener.remove();\n      this.onPolygonClickListener = undefined;\n    }\n\n    if (this.onCircleClickListener) {\n      this.onCircleClickListener.remove();\n      this.onCircleClickListener = undefined;\n    }\n\n    if (this.onMarkerDragStartListener) {\n      this.onMarkerDragStartListener.remove();\n      this.onMarkerDragStartListener = undefined;\n    }\n\n    if (this.onMarkerDragListener) {\n      this.onMarkerDragListener.remove();\n      this.onMarkerDragListener = undefined;\n    }\n\n    if (this.onMarkerDragEndListener) {\n      this.onMarkerDragEndListener.remove();\n      this.onMarkerDragEndListener = undefined;\n    }\n\n    if (this.onMyLocationButtonClickListener) {\n      this.onMyLocationButtonClickListener.remove();\n      this.onMyLocationButtonClickListener = undefined;\n    }\n\n    if (this.onMyLocationClickListener) {\n      this.onMyLocationClickListener.remove();\n      this.onMyLocationClickListener = undefined;\n    }\n  }\n\n  private generateCallback(\n    callback: MapListenerCallback<any>,\n  ): MapListenerCallback<any> {\n    const mapId = this.id;\n    return (data: any) => {\n      if (data.mapId == mapId) {\n        callback(data);\n      }\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
